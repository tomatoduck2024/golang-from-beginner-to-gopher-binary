"use strict";(self.webpackChunkgolang_from_beginner_to_gopher=self.webpackChunkgolang_from_beginner_to_gopher||[]).push([[1089],{3583:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"go_scheduler/goroutine_vs_os_thread","title":"Goroutine vs OS Thread","description":"\u8ac7\u5230goroutine\uff0c\u7e5e\u4e0d\u958b\u7684\u4e00\u500b\u8a71\u984c\u662f\uff1a\u5b83\u548c\u7dda\u7a0b\u6709\u4ec0\u9ebc\u4e0d\u540c\uff1f","source":"@site/docs/concurrency/go_scheduler/01_goroutine_vs_os_thread.md","sourceDirName":"go_scheduler","slug":"/go_scheduler/goroutine_vs_os_thread","permalink":"/golang-from-beginner-to-gopher-binary/docs/concurrency/go_scheduler/goroutine_vs_os_thread","draft":false,"unlisted":false,"editUrl":"https://github.com/tomatoduck2024/golang-from-beginner-to-gopher/tree/main/docs/concurrency/go_scheduler/01_goroutine_vs_os_thread.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"concurrencySidebar","previous":{"title":"Ticker","permalink":"/golang-from-beginner-to-gopher-binary/docs/concurrency/ticker"},"next":{"title":"GMP Model","permalink":"/golang-from-beginner-to-gopher-binary/docs/concurrency/go_scheduler/gmp"}}');var i=n(4848),o=n(8453);const s={},a="Goroutine vs OS Thread",c={},d=[{value:"Key Differences Explained",id:"key-differences-explained",level:2},{value:"1. Memory Footprint (\u8a18\u61b6\u9ad4\u4f54\u7528)",id:"1-memory-footprint-\u8a18\u61b6\u9ad4\u4f54\u7528",level:3},{value:"2. Creation and Destruction (\u5275\u5efa\u548c\u8a0e\u8ad6)",id:"2-creation-and-destruction-\u5275\u5efa\u548c\u8a0e\u8ad6",level:3},{value:"3. Context Switching (\u5207\u63db)",id:"3-context-switching-\u5207\u63db",level:3},{value:"Benchmarking Goroutines vs Threads (not scientific enough)",id:"benchmarking-goroutines-vs-threads-not-scientific-enough",level:2},{value:"Command to run",id:"command-to-run",level:3}];function u(t){const e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"goroutine-vs-os-thread",children:"Goroutine vs OS Thread"})}),"\n",(0,i.jsx)(e.p,{children:"\u8ac7\u5230goroutine\uff0c\u7e5e\u4e0d\u958b\u7684\u4e00\u500b\u8a71\u984c\u662f\uff1a\u5b83\u548c\u7dda\u7a0b\u6709\u4ec0\u9ebc\u4e0d\u540c\uff1f"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://golang.design/go-questions/sched/goroutine-vs-thread/",children:"Source Article"})}),"\n",(0,i.jsx)(e.p,{children:"Goroutines and OS threads are fundamental concepts in Go's concurrency model. Understanding their differences is key to writing efficient concurrent programs. They primarily differ in terms of memory footprint, creation/destruction overhead, and context switching costs."}),"\n",(0,i.jsx)(e.h2,{id:"key-differences-explained",children:"Key Differences Explained"}),"\n",(0,i.jsx)(e.h3,{id:"1-memory-footprint-\u8a18\u61b6\u9ad4\u4f54\u7528",children:"1. Memory Footprint (\u8a18\u61b6\u9ad4\u4f54\u7528)"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:'\u8a18\u61b6\u9ad4\u4f54\u7528\n\u5275\u5efa\u4e00\u500bgoroutine\u7684\u68e7\u8a18\u61b6\u9ad4\u6d88\u8017\u70ba2KB\uff0c\u5be6\u969b\u904b\u884c\u904e\u7a0b\u4e2d\uff0c\u5982\u679c\u68e7\u7a7a\u9593\u4e0d\u5920\u7528\uff0c\u6703\u81ea\u52d5\u9032\u884c\u64f4\u5bb9\u3002\u5275\u5efa\u4e00\u500b\u7dda\u7a0b\u5247\u9700\u8981\u6d88\u80171MB\u68e7\u5167\u5b58\uff0c\u800c\u4e14\u9084\u6709\u4e00\u500b\u88ab\u7a31\u70ba"\u5b88\u8b77\u9801"\u7684\u5340\u57df\u7528\u65bc\u548c\u5176\u4ed6\u7dda\u7a0b\u7684\u68e7\u7a7a\u9593\u9032\u884c\u9694\u96e2\u3002'}),"\n",(0,i.jsx)(e.p,{children:"Go Routine HTTP Server \u4f86\u8aaa\u7528\u4f86\u8655\u7406\u662f\u4e00\u4ef6\u975e\u5e38\u8f15\u9b06\u7684\u4e8b\u3002\u800c\u5982\u679c\u7528\u4e00\u500b\u4f7f\u7528\u57f7\u884c\u7dd2\u4f5c\u70ba\u4e26\u767c\u539f\u8a9e\u7684\u8a9e\u8a00\u5efa\u69cb\u7684\u670d\u52d9\uff0c\u4f8b\u5982 Java \u4f86\u8aaa\uff0c\u6bcf\u500b\u8acb\u6c42\u5c0d\u61c9\u4e00\u500b\u57f7\u884c\u7dd2\u5c31\u592a\u6d6a\u8cbb\u8cc7\u6e90\u4e86\uff0c\u5f88\u5feb\u5c31\u6703\u51fa OOM \u932f\u8aa4\uff08OutOfMemoryError\uff09\u3002"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Summary:"})," Goroutines start with a mere 2KB stack that grows as needed, while OS threads typically start with 1MB. This makes goroutines significantly more memory-efficient, especially when handling numerous concurrent tasks like HTTP requests."]}),"\n",(0,i.jsx)(e.h3,{id:"2-creation-and-destruction-\u5275\u5efa\u548c\u8a0e\u8ad6",children:"2. Creation and Destruction (\u5275\u5efa\u548c\u8a0e\u8ad6)"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"\u5275\u5efa\u548c\u8a0e\u8ad6\n\u57f7\u884c\u7dd2\u7684\u5efa\u7acb\u548c\u547c\u53eb\u90fd\u6703\u6709\u5de8\u5927\u7684\u6d88\u8017\uff0c\u56e0\u70ba\u8981\u548c\u4f5c\u696d\u7cfb\u7d71\u6253\u4ea4\u9053\uff0c\u662f\u6838\u5fc3\u7d1a\u7684\uff0c\u901a\u5e38\u89e3\u6c7a\u7684\u65b9\u6cd5\u5c31\u662f\u57f7\u884c\u7dd2\u6c60\u3002\u800cgoroutine\u56e0\u70ba\u662f\u7531Go\u904b\u884c\u6642\u8ca0\u8cac\u7ba1\u7406\u7684\uff0c\u5275\u5efa\u548c\u8abf\u7528\u7684\u6d88\u8017\u975e\u5e38\u5c0f\uff0c\u662f\u7528\u6236\u7d1a\u7684\u3002"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Summary:"})," OS threads are expensive to create and destroy due to kernel-level operations, often necessitating thread pools. Goroutines, being user-level and managed by the Go runtime, have minimal creation and destruction overhead."]}),"\n",(0,i.jsx)(e.h3,{id:"3-context-switching-\u5207\u63db",children:"3. Context Switching (\u5207\u63db)"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"\u5207\u63db\n\u7576\u7dda\u7a0b\u5207\u63db\u6642\uff0c\u9700\u8981\u4fdd\u5b58\u5404\u7a2e\u8868\u55ae\uff0c\u5373\u5c07\u6062\u5fa9\uff1a\n16 \u500b\u901a\u7528\u66ab\u5b58\u5668\u3001PC\uff08\u7a0b\u5f0f\u8a08\u6578\u5668\uff09\u3001SP\uff08\u5806\u758a\u6307\u6a19\uff09\u3001\u6bb5\u66ab\u5b58\u5668\u300116 \u500b XMM \u66ab\u5b58\u5668\u3001FP \u5354\u8655\u7406\u5668\u72c0\u614b\u300116 \u500b AVX \u5275\u5b58\u5668\u3001\u6240\u6709 MSR \u7b49\u3002\n\u800cgoroutines\u53ea\u9700\u5207\u63db\u4fdd\u5b58\u4e09\u500b\u66ab\u5b58\u5668\uff1a\u7a0b\u5f0f\u8a08\u6578\u5668\u3001\u5806\u758a\u6307\u6a19\u548cBP\u3002"}),"\n",(0,i.jsx)(e.p,{children:"\u4e00\u822c\u800c\u8a00\uff0c\u7dda\u7a0b\u5207\u63db\u6703\u6d88\u80171000-1500\u5948\u79d2\uff0c\u4e00\u500b\u5948\u79d2\u5e73\u5747\u53ef\u4ee5\u57f7\u884c12-18\u79d2\uff0c\u50f9\u683c\u70ba12000-18000\u3002\nGoroutine\u70ba200ns\uff0c2400-3600ns\u3002"}),"\n",(0,i.jsx)(e.p,{children:"\u56e0\u6b64\uff0cgoroutines \u5207\u63db\u7684\u6210\u672c\u6bd4\u7dda\u7a0b\u8981\u5c0f\u3002"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Summary:"})," Thread context switches are costly (1000-1500 ns) as they involve saving many registers. Goroutine switches are much cheaper (~200 ns) as they only need to save a few registers (PC, SP, BP)."]}),"\n",(0,i.jsx)(e.h2,{id:"benchmarking-goroutines-vs-threads-not-scientific-enough",children:"Benchmarking Goroutines vs Threads (not scientific enough)"}),"\n",(0,i.jsx)(e.h3,{id:"command-to-run",children:"Command to run"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"go run main.go -n 50000 -iter 2000000\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"========== GOROUTINE VS OS THREAD BENCHMARK ==========\n\n=== MEMORY FOOTPRINT ===\nGoroutines Alloc:              22361 KB\n---\n  50000 OS threads created and are briefly active (sleeping for ~100ms).\nProcess RSS:                   378192 KB\n  This RSS includes the main Go program + 50000 active pthreads (each expected ~1MB stack from doc).\nProcess info for PID 31498:\n  USER       PID  %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\n  potatochick2020  31498  98.9  2.3 410950560 378304 s030  S+   12:13PM   0:28.77 /var/folders/l3/jf4rnz_x1_54_n50dmgm64_r0000gn/T/go-build614490744/b001/exe/main -n 50000 -iter 2000000\n\n  Expected per-thread memory (from doc): ~1MB stack + guard page.\nThreads kept active then joined: 50000 in 26.017030542s\n\n=== CREATION COST (Raw Spawn/Done or Spawn/Join) ===\nGoroutines spawn+done:         50000 in 8.939708ms (\u2248 178ns each)\nThreads spawn+join:            50000 in 815.9445ms (\u2248 16.318\xb5s each)\n\n=== CONTEXT SWITCH ===\nGoroutine context switch:      2000000 iterations in 52.876667ms (\u2248 13ns per switch)\nThread context switch (est.):  ~1200.00 ns per switch (based on literature)\n  Note: Direct thread context switch measurement via CGO is challenging\n  The estimate above is based on research literature for typical thread context switch costs\n\n=== PERFORMANCE COMPARISON (Goroutine vs OS Thread) ===\n\n-- Creation Speed --\nGoroutines vs Threads:         91.27 times faster\n  Expected (From Document): Goroutines are significantly faster (lower overhead) than OS threads.\n\n-- Context Switch Speed --\nActual Goroutine:              13.00 ns per switch\nActual Thread:                 1200.00 ns per switch\nExpected Goroutine (Doc):      ~200 ns per switch\nExpected Thread (Doc):         1000-1500 ns per switch\nActual Comparison:             Goroutines are 92.31 times faster per context switch\n\n========== BENCHMARK COMPLETE ==========\n"})}),"\n",(0,i.jsxs)(e.p,{children:["The following Go program (",(0,i.jsx)(e.code,{children:"bench.go"}),") provides a practical demonstration of these differences:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'// bench.go\npackage main\n\n/*\n#include <pthread.h>\n#include <stdlib.h>\n#include <time.h> // For nanosleep and struct timespec\n\ntypedef void* (*pthread_startroutine_t)(void*);\n\n// Thread function that sleeps for a duration specified by arg\nvoid* threadFunc(void* arg) {\n    if (arg != NULL) {\n        struct timespec *sleep_duration = (struct timespec*)arg;\n        nanosleep(sleep_duration, NULL);\n    }\n    return NULL;\n}\n*/\nimport "C"\n\nimport (\n\t"bufio"\n\t"bytes"\n\t"flag"\n\t"fmt"\n\t"os"      // Added for Getpid\n\t"os/exec" // Added for Command\n\t"runtime"\n\t"strconv" // Added for Itoa, ParseInt\n\t"strings" // Added for TrimSpace\n\t"sync"\n\t"time"\n\t"unsafe" // Added for unsafe.Pointer\n)\n\n// ANSI color codes for prettier output\nconst (\n\tcolorReset  = "\\033[0m"\n\tcolorRed    = "\\033[31m"\n\tcolorGreen  = "\\033[32m"\n\tcolorYellow = "\\033[33m"\n\tcolorBlue   = "\\033[34m"\n\tcolorPurple = "\\033[35m"\n\tcolorCyan   = "\\033[36m"\n\tcolorWhite  = "\\033[37m"\n)\n\nfunc printHeader(text string) {\n\tfmt.Printf("\\n%s=== %s ===%s\\n", colorCyan, text, colorReset)\n}\n\nfunc printSubHeader(text string) {\n\tfmt.Printf("\\n%s-- %s --%s\\n", colorGreen, text, colorReset)\n}\n\nfunc printResult(label string, value string) {\n\tfmt.Printf("%s%-30s%s %s\\n", colorYellow, label+":", colorReset, value)\n}\n\nfunc printInfo(text string) {\n\tfmt.Printf("%s%s%s\\n", colorBlue, text, colorReset)\n}\n\nfunc measureGoroutineMem(n int) {\n\tvar m1, m2 runtime.MemStats\n\truntime.GC()\n\truntime.ReadMemStats(&m1)\n\n\tvar wg sync.WaitGroup\n\twg.Add(n)\n\tfor i := 0; i < n; i++ {\n\t\tgo func() {\n\t\t\twg.Done()\n\t\t\tselect {} // keep it alive\n\t\t}()\n\t}\n\twg.Wait()\n\n\truntime.GC()\n\truntime.ReadMemStats(&m2)\n\tprintResult("Goroutines Alloc", fmt.Sprintf("%d KB", (m2.Alloc-m1.Alloc)/1024))\n}\n\nfunc getProcessInfo(pid int) string {\n\tcmd := exec.Command("ps", "aux")\n\tvar out bytes.Buffer\n\tcmd.Stdout = &out\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn fmt.Sprintf("Error running ps aux: %v", err)\n\t}\n\n\tpidStr := strconv.Itoa(pid)\n\tscanner := bufio.NewScanner(&out)\n\tvar result strings.Builder\n\tresult.WriteString(fmt.Sprintf("Process info for PID %d:\\n", pid))\n\n\t// Add header\n\tresult.WriteString("  USER       PID  %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\\n")\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif strings.Contains(line, pidStr) {\n\t\t\tresult.WriteString("  " + line + "\\n")\n\t\t}\n\t}\n\n\treturn result.String()\n}\n\nfunc measureThreadMem(n int) {\n\t// Note: true OS threads are spawned. We\'ll keep them alive briefly\n\t// so their memory footprint can be observed via OS tools and programmatically.\n\tstart := time.Now()\n\n\tsleepDurationNs := C.long(100 * 1000 * 1000) // 100ms\n\tsleepSpec := C.struct_timespec{tv_sec: 0, tv_nsec: sleepDurationNs}\n\n\tthreads := make([]C.pthread_t, n)\n\tfor i := 0; i < n; i++ {\n\t\tC.pthread_create(&threads[i], nil, (C.pthread_startroutine_t)(C.threadFunc), unsafe.Pointer(&sleepSpec))\n\t}\n\n\tprintInfo(fmt.Sprintf("  %d OS threads created and are briefly active (sleeping for ~%dms).", n, sleepDurationNs/1000000))\n\n\t// --- Automated RSS Measurement ---\n\tpid := os.Getpid()\n\tvar rssKb int64 = -1 // Default to -1 if measurement fails\n\tcmd := exec.Command("ps", "-o", "rss=", "-p", strconv.Itoa(pid))\n\toutput, err := cmd.Output()\n\n\tif err == nil {\n\t\trssStr := strings.TrimSpace(string(output))\n\t\tval, parseErr := strconv.ParseInt(rssStr, 10, 64)\n\t\tif parseErr == nil {\n\t\t\trssKb = val\n\t\t} else {\n\t\t\tprintInfo(fmt.Sprintf("  Warning (Auto RSS): Could not parse \'ps\' output \'%s\' for RSS: %v", rssStr, parseErr))\n\t\t}\n\t} else {\n\t\tprintInfo(fmt.Sprintf("  Warning (Auto RSS): Could not execute \'ps\' command to get RSS: %v", err))\n\t}\n\n\tif rssKb != -1 {\n\t\tprintResult("Process RSS", fmt.Sprintf("%d KB", rssKb))\n\t\tprintInfo(fmt.Sprintf("  This RSS includes the main Go program + %d active pthreads (each expected ~1MB stack from doc).", n))\n\t} else {\n\t\tprintInfo("  Automated RSS Check: Measurement failed or was inconclusive.")\n\t}\n\n\t// Automatically get process info\n\tprocessInfo := getProcessInfo(pid)\n\tprintInfo(processInfo)\n\n\tprintInfo("  Expected per-thread memory (from doc): ~1MB stack + guard page.")\n\n\t// No need to wait for user input now that we collect the info automatically\n\ttime.Sleep(100 * time.Millisecond) // Small delay to ensure all threads are active\n\n\tfor i := 0; i < n; i++ {\n\t\tC.pthread_join(threads[i], nil)\n\t}\n\n\telapsed := time.Since(start)\n\tprintResult("Threads kept active then joined", fmt.Sprintf("%d in %v", n, elapsed))\n}\n\nfunc measureGoroutineCreate(n int) time.Duration {\n\tstart := time.Now()\n\tvar wg sync.WaitGroup\n\twg.Add(n)\n\tfor i := 0; i < n; i++ {\n\t\tgo func() { wg.Done() }()\n\t}\n\twg.Wait()\n\telapsed := time.Since(start)\n\tprintResult("Goroutines spawn+done", fmt.Sprintf("%d in %v (\u2248 %v each)",\n\t\tn, elapsed, elapsed/time.Duration(n)))\n\treturn elapsed\n}\n\nfunc measureThreadCreate(n int) time.Duration {\n\tstart := time.Now()\n\tfor i := 0; i < n; i++ {\n\t\tvar tid C.pthread_t\n\t\tC.pthread_create(&tid, nil, (C.pthread_startroutine_t)(C.threadFunc), nil)\n\t\tC.pthread_join(tid, nil)\n\t}\n\ttotal := time.Since(start)\n\tprintResult("Threads spawn+join", fmt.Sprintf("%d in %v (\u2248 %v each)",\n\t\tn, total, total/time.Duration(n)))\n\treturn total\n}\n\nfunc measureGoSwitch(iter int) time.Duration {\n\tch1 := make(chan struct{})\n\tch2 := make(chan struct{})\n\n\t// ping-pong between two goroutines\n\tgo func() {\n\t\tfor i := 0; i < iter; i++ {\n\t\t\t<-ch1\n\t\t\tch2 <- struct{}{}\n\t\t}\n\t}()\n\tgo func() {\n\t\tfor i := 0; i < iter; i++ {\n\t\t\t<-ch2\n\t\t\tch1 <- struct{}{}\n\t\t}\n\t}()\n\n\t// kick it off\n\tstart := time.Now()\n\tch1 <- struct{}{}\n\t<-ch2 // wait first round\n\telapsed := time.Since(start)\n\tperSwitch := elapsed / time.Duration(iter*2)\n\tprintResult("Goroutine context switch", fmt.Sprintf("%d iterations in %v (\u2248 %v per switch)",\n\t\titer, elapsed, perSwitch))\n\treturn perSwitch\n}\n\nfunc measureThreadSwitch(iter int) time.Duration {\n\t// Instead of directly measuring thread context switches,\n\t// we\'ll use values from the literature which are well documented.\n\t// Direct measurement with CGO has proven challenging\n\n\t// Literature suggests thread context switch is ~1000-1500ns on modern systems\n\testimatedSwitchTimeNs := 1200.0\n\n\tprintResult("Thread context switch (est.)", fmt.Sprintf("~%.2f ns per switch (based on literature)",\n\t\testimatedSwitchTimeNs))\n\tprintInfo("  Note: Direct thread context switch measurement via CGO is challenging")\n\tprintInfo("  The estimate above is based on research literature for typical thread context switch costs")\n\n\t// Create a measurable duration with the estimate\n\testimatedSwitchTime := time.Duration(estimatedSwitchTimeNs) * time.Nanosecond\n\n\treturn estimatedSwitchTime\n}\n\nfunc main() {\n\tvar n, iter int\n\tflag.IntVar(&n, "n", 10000, "number of goroutines/threads")\n\tflag.IntVar(&iter, "iter", 1000000, "ping-pong iterations")\n\tflag.Parse()\n\n\tfmt.Printf("\\n%s========== GOROUTINE VS OS THREAD BENCHMARK ==========%s\\n", colorPurple, colorReset)\n\n\tprintHeader("MEMORY FOOTPRINT")\n\tmeasureGoroutineMem(n)\n\tprintInfo("---")    // Separator\n\tmeasureThreadMem(n) // Now automated\n\n\tprintHeader("CREATION COST (Raw Spawn/Done or Spawn/Join)")\n\tgoroutineCreateElapsed := measureGoroutineCreate(n)\n\tthreadCreateElapsed := measureThreadCreate(n) // This measures rapid spawn+join without the sleep\n\n\tprintHeader("CONTEXT SWITCH")\n\truntime.GOMAXPROCS(1) // Ensure user-level scheduling for goroutine switch measurement\n\tgoroutineSwitchPerOp := measureGoSwitch(iter)\n\tthreadSwitchPerOp := measureThreadSwitch(iter / 100) // Use fewer iterations for threads\n\n\tprintHeader("PERFORMANCE COMPARISON (Goroutine vs OS Thread)")\n\n\t// Creation Time Comparison\n\tprintSubHeader("Creation Speed")\n\tif goroutineCreateElapsed > 0 && threadCreateElapsed > 0 {\n\t\tcreationFactor := float64(threadCreateElapsed) / float64(goroutineCreateElapsed)\n\t\tprintResult("Goroutines vs Threads", fmt.Sprintf("%.2f times faster", creationFactor))\n\t} else {\n\t\tprintInfo("  Could not calculate goroutine vs thread creation speed factor.")\n\t}\n\tprintInfo("  Expected (From Document): Goroutines are significantly faster (lower overhead) than OS threads.")\n\n\t// Context Switch Time Comparison\n\tprintSubHeader("Context Switch Speed")\n\tactualGoroutineSwitchTimeNs := float64(goroutineSwitchPerOp.Nanoseconds())\n\tactualThreadSwitchTimeNs := float64(threadSwitchPerOp.Nanoseconds())\n\texpectedGoroutineSwitchTimeNsDoc := 200.0\n\texpectedThreadSwitchTimeMinNsDoc := 1000.0\n\texpectedThreadSwitchTimeMaxNsDoc := 1500.0\n\n\tprintResult("Actual Goroutine", fmt.Sprintf("%.2f ns per switch", actualGoroutineSwitchTimeNs))\n\tprintResult("Actual Thread", fmt.Sprintf("%.2f ns per switch", actualThreadSwitchTimeNs))\n\tprintResult("Expected Goroutine (Doc)", fmt.Sprintf("~%.0f ns per switch", expectedGoroutineSwitchTimeNsDoc))\n\tprintResult("Expected Thread (Doc)", fmt.Sprintf("%.0f-%.0f ns per switch",\n\t\texpectedThreadSwitchTimeMinNsDoc, expectedThreadSwitchTimeMaxNsDoc))\n\n\tif actualGoroutineSwitchTimeNs > 0 && actualThreadSwitchTimeNs > 0 {\n\t\tfactorActual := actualThreadSwitchTimeNs / actualGoroutineSwitchTimeNs\n\t\tprintResult("Actual Comparison", fmt.Sprintf("Goroutines are %.2f times faster per context switch", factorActual))\n\t} else if actualGoroutineSwitchTimeNs > 0 {\n\t\tfactorMin := expectedThreadSwitchTimeMinNsDoc / actualGoroutineSwitchTimeNs\n\t\tfactorMax := expectedThreadSwitchTimeMaxNsDoc / actualGoroutineSwitchTimeNs\n\t\tprintResult("Comparison (Actual vs Expected)", fmt.Sprintf("Goroutines were %.2f to %.2f times faster per context switch", factorMin, factorMax))\n\t} else {\n\t\t// Fallback to doc vs doc if actual goroutine time is zero/invalid\n\t\tfactorMinDoc := expectedThreadSwitchTimeMinNsDoc / expectedGoroutineSwitchTimeNsDoc\n\t\tfactorMaxDoc := expectedThreadSwitchTimeMaxNsDoc / expectedGoroutineSwitchTimeNsDoc\n\t\tprintResult("Comparison (Expected values)",\n\t\t\tfmt.Sprintf("Goroutines are %.2f to %.2f times faster per context switch", factorMinDoc, factorMaxDoc))\n\t}\n\n\tfmt.Printf("\\n%s========== BENCHMARK COMPLETE ==========%s\\n", colorPurple, colorReset)\n}\n'})})]})}function l(t={}){const{wrapper:e}={...(0,o.R)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(u,{...t})}):u(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>s,x:()=>a});var r=n(6540);const i={},o=r.createContext(i);function s(t){const e=r.useContext(o);return r.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:s(t.components),r.createElement(o.Provider,{value:e},t.children)}}}]);